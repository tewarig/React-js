import { Scope } from '@sentry/types';
interface Action<T = any> {
    type: T;
}
interface AnyAction extends Action {
    [extraProps: string]: any;
}
declare type Reducer<S = any, A extends Action = AnyAction> = (state: S | undefined, action: A) => S;
declare type Dispatch<A extends Action = AnyAction> = <T extends A>(action: T, ...extraArgs: any[]) => T;
declare type ExtendState<State, Extension> = [Extension] extends [never] ? State : State & Extension;
declare type Unsubscribe = () => void;
interface Store<S = any, A extends Action = AnyAction, StateExt = never, Ext = {}> {
    dispatch: Dispatch<A>;
    getState(): S;
    subscribe(listener: () => void): Unsubscribe;
    replaceReducer<NewState, NewActions extends Action>(nextReducer: Reducer<NewState, NewActions>): Store<ExtendState<NewState, StateExt>, NewActions, StateExt, Ext> & Ext;
}
declare const $CombinedState: unique symbol;
declare type CombinedState<S> = {
    readonly [$CombinedState]?: undefined;
} & S;
declare type PreloadedState<S> = Required<S> extends {
    [$CombinedState]: undefined;
} ? S extends CombinedState<infer S1> ? {
    [K in keyof S1]?: S1[K] extends object ? PreloadedState<S1[K]> : S1[K];
} : never : {
    [K in keyof S]: S[K] extends string | number | boolean | symbol ? S[K] : PreloadedState<S[K]>;
};
declare type StoreEnhancer<Ext = {}, StateExt = never> = (next: StoreEnhancerStoreCreator<Ext, StateExt>) => StoreEnhancerStoreCreator<Ext, StateExt>;
declare type StoreEnhancerStoreCreator<Ext = {}, StateExt = never> = <S = any, A extends Action = AnyAction>(reducer: Reducer<S, A>, preloadedState?: PreloadedState<S>) => Store<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext;
export interface SentryEnhancerOptions {
    /**
     * Transforms the state before attaching it to an event.
     * Use this to remove any private data before sending it to Sentry.
     * Return null to not attach the state.
     */
    stateTransformer<S>(state: S | undefined): (S & any) | null;
    /**
     * Transforms the action before sending it as a breadcrumb.
     * Use this to remove any private data before sending it to Sentry.
     * Return null to not send the breadcrumb.
     */
    actionTransformer(action: AnyAction): AnyAction | null;
    /**
     * Called on every state update, configure the Sentry Scope with the redux state.
     */
    configureScopeWithState?<S>(scope: Scope, state: S): void;
}
/**
 * Creates an enhancer that would be passed to Redux's createStore to log actions and the latest state to Sentry.
 *
 * @param enhancerOptions Options to pass to the enhancer
 */
declare function createReduxEnhancer(enhancerOptions?: Partial<SentryEnhancerOptions>): StoreEnhancer;
export { createReduxEnhancer };
//# sourceMappingURL=redux.d.ts.map